#### 1.1.1 进程与线程的概念

- 进程是资源分配的最小单位，线程是CPU调度和分配的最小单位。

- 看到过一个比喻，将进程=火车，线程=车厢
  
  - 线程需要在进程下才能运行(单个车厢无法独立运行)
  
  - 一个进程可以包含多个线程(一辆火车可以包含多个车厢)
  
  - 不同进程之间的数据很难共享(一辆火车中的乘客换到另一辆火车上比较麻烦，只有站点换乘)
  
  - 同一个进程中的不同线程间资源很容易共享(即一辆火车上A车厢到B车厢)
  
  - 进程要比线程消耗更多的计算机资源(多列火车消耗的资源比单列火车多个车厢多)
  
  - 进程间不会相互影响，某进程中一个线程挂掉可能导致整个进程挂掉(不同火车之间无影响，但同一火车的某个车厢着火，其他的车厢可能也会受到影响)
  
  - 进程可以扩展到多机，线程最多扩展到多核(不同的火车可以开在多个不同的轨道上，同一辆火车不能行驶在不同轨道上,每个车厢的乘客都可以同步进行一些事情)
  
  - 进程（线程）使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等待其结束才能使用。(如车厢上的唯一公共场所，"互斥锁")
  
  - 进程（线程）使用的内存地址可以限定其使用量(如火车上餐厅，只能允许多少人进入，若超出，只能等待里面的人出来才能进去，"信号量")

- 举例
  
  ```cpp
  #include<pthread.h>
  #include<stdio.h>
  #include<string.h>
  #include<unistd.h>
  
  int g_cnt=0 //全局变量
  int *thread(void *arg){
      int m_cnt = 0;
      m_cnt = 5;
      g_cnt++;
      return 0;
  }
  
  int main(void){
      int err = 0;
      pthread_t tid;
      int m_cnt = 0;
      err = pthread_create(&tid,NULL,thread,NULL); //创建子线程
      if(0!=err){ //检验是否创建成功
          printf("can't create:%s\n",strerror(err));
      } 
      while(g_cnt==0){
          usleep(300); //延迟300ms
      }
      printf("g_cnt=%d,m_cnt=%d\n",g_cnt,m_cnt);
      return 0;
  }
  ```
  
  最后输出结果为：
  
  ```cpp
  g_cnt=1,m_cnt=0
  ```

#### 1.1.2 多进程、多线程的优缺点

- 多进程一个进程挂了不影响其他进程，子进程挂掉也不会影响主进程，因为系统会给进程分配独立的资源。多线程中一个线程挂掉，可能会影响到整个程序，因为多线程是在一个进程中工作。

- 进程的性能远远大于线程，因为进程都具有独立的地址空间和资源。而多个线程是共享同一个进程的空间资源，进程的性能远远大于线程。因此创建多进程的系统花销远远大于创建多线程。

- 多进程不适合大量数据传送，多线程更适合大量数据之间传送，因为多线程可以共享同一进程里的共享内存和变量。

- 多线程需要复杂的线程同步和加锁机制，而多进程间不需要。

- 进程的数量可以通过增加CPU的数量来增加，而线程数量由进程的空间资源和线程本身栈大小来确定。

#### 1.1.3 进程和线程的使用场景

- 创建和销毁较为频繁使用线程，因为进程开销大。

- 需要大量数据传送要使用进程，因为多线程切换速度快，不需要跨越进程边界。

- 并行操作的时候使用线程。

总结：安全稳定选择进程；快速频繁选择线程。

#### 1.1.4 多进程、多线程通讯方式

- 进程间通讯方式
  
  - 管道/无名管道
  
  - 信号
  
  - 共享内存
  
  - 消息队列
  
  - 信号量
  
  - socket

- 线程间通讯
  
  - 信号量
  
  - 读写锁
  
  - 条件变量
  
  - 互斥锁
  
  - 自旋锁

- 互斥锁和信号量区别
  
  互斥锁用于线程互斥，信号量用于线程同步。互斥锁的作用域仅仅在于线程，信号量可以用于线程和进程。

#### 1.1.5 进程空间模型

- 简介
  
  32位操作系统中，当系统运行一个程序，就会创建一个程序，系统分配4G的虚拟内存，其中，0-3G是用户空间，3-4G是内核空间，内核空间是受保护的，用户不能对该空间进行读写操作，否则可能出现段操作。栈空间的数据地址增加的空间是往下的，新的数据的地址值反而更小，而堆空间则是往上的。

- 内核空间模型
  
  | 3G-4G   内存管理 进程管理 设备驱动管理 VFS虚拟文件系统 |
  |:----------------------------------:|
  | 环境变量                               |
  | 命令行参数                              |
  | 栈空间（小）                             |
  | 共享库                                |
  | 堆空间（大）                             |
  | .bss（未初始化全局变量）                     |
  | .data（已初始化全局变量）                    |
  | .text（代码段）                         |
  | 受保护的地址（0-4k）                       |

- 详解
  
  - 栈区
    
    由编译器自动分配和释放，存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈，先进后出。
  
  - 堆区
    
    由程序员分配和释放，若自己不释放，可能会产生内存泄漏，程序结束的时候可能由操作系统回收，其与数据结构中堆不一样，类似于链表。
  
  - 全局区（静态区）
    
    全局变量和静态变量存储在一块，初始化的全局变量和静态变量在一块区域，即（.data）,未初始化的全局变量和未初始化的静态变量在相邻的一块区域，即(.bss),程序结束后系统释放。
  
  - 常量区
    
    常量字符串存在这里，程序结束后系统释放。
  
  - 程序代码段
    
    即（.text），存放函数体的二进制代码
  
  - 栈的空间有限，堆是自由存储区，程序在编译器对变量和函数分配内存都在栈上进行，且程序允许过程中函数调用时参数的传递也是在栈上进行。

- 注意点
  
  64位操作系统下的虚拟内存空间大小，地址空间大小不是2的32次方，也不是2的64次方，一般是2的48次方。因为不需要2的64次方的寻址空间，可能会造成资源浪费。所有64位Linux一般使用48位表示虚拟空间地址，40位表示物理地址。0x0000000000000000~0X00007fffffffffff表示用户空间，0xFFFF800000000000~0xFFFFFFFFFFFFFFFF表示内核空间，提供256T(2的48次方)的寻址空间。

#### 1.1.6 一个进程创建的线程数量以及限制

- 一个进程创建线程的数量由虚拟内存和分配给线程的调用栈大小决定

- 创建一个进程，系统会分配4G虚拟内存，其中1G是内核空间，3G是用户空间，也就是创建线程的空间，一个线程的栈的大小可以通过ulimit-s指令来查看，一般来讲是8M-10M。

#### 1.1.7 进程状态转换图，何时阻塞，何时就绪

- 状态详解
  
  - 创建态：一个进程正在创建，还没有转变为就绪态之前的状态。
  
  - 就绪态：一个进程获得了除CPU时间片之外的一切所需资源，一旦得到CPU时间片调度即可允许。
  
  - 运行/执行态：当一个进程得到CPU调度正在处理机上运行时的状态。
  
  - 睡眠/挂起态：由于某些资源暂时不可得到而进入"睡眠态"，将进程挂起，等待唤醒。
  
  - 阻塞/暂停态：一个进程正在等待某一件事而暂时运行时，如等待某资源成为可用，或等待文件读取完成。
  
  - 结束/僵尸态：一个进程正在从系统中消失时的状态，这是因为进程结束或其他因流产所导致。
  
  - 死亡态：进程生命周期结束，将所占用的资源还给系统。

- 过程
  
  - 从父进程调用fork()创建子进程开始，此时子进程处于创建态，此时系统为进程分配地址和资源后将进程加入就绪队列，进入就绪态。就绪态的进程得到了CPU时间片调度正式进行，进入执行态。
  
  - 执行态有以下四种结果：
    
    - 当时间片耗光或者被其他进程抢占，则重新进入就绪态，等待下次CPU时间片。
    
    - 由于某些资源暂时不可得到而进入"睡眠态"（如要读取的文件为为空或要得到的某个锁还处于不可获得状态），等待资源获得后再唤醒，进入就绪态。
    
    - 收到SIGSTOP/SIGTSTP信号进入暂停态，知道收到SIGCONT信号重新进入就绪态。
    
    - 进程结束后，通过内核调用do_exit()僵尸态，等待系统回收资源。当父进程调用wait()/waitpid()后接收结束子进程，该进程进入死亡态。

- 流程图
  
  ![page]([C:\Users\Administrator\AppData\Roaming\marktext\images\2023-07-16-15-10-06-image.png](https://github.com/1548798163/Embedded-interview-questions/blob/master/pages/1.1.7.PNG))

#### 1.1.8 父进程与子进程的关系与区别

- 子进程继承了父进程的部分
  
  - 用户号UIDs和用户组号GIDs
  
  - 环境Env
  
  - 堆和栈
  
  - 共享内存
  
  - 文件描述符
  
  - 执行时关闭标志
  
  - 信号控制(Signal)设置
  
  - 进程组号
  
  - 当前工作目录和根目录
  
  - 文件方式创建屏蔽字
  
  - 资源限制
  
  - 控制终端

- 子线程独有
  
  - 进程号PID
  
  - 不同的父进程号
  
  - 自己的文件描述符和目录流的拷贝
  
  - 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
  
  - 不继承异步输入和输出

- 联系
  
  当父进程fock()出一个子进程后，子进程和父进程拥有相同内容的代码段、数据段和用户堆栈。其实父进程只是复制了自己的PCB，而代码段、数据段和用户堆栈内存空间是和子进程共享的。只有当子进程在运行中出现写操作时，才会发生中断，并为子进程分配内存空间。
  
  子进程从父进程继承的主要有：用户号和用户组号；堆栈；共享内存；目录（当前和根目录）；打开文件的描述符。父进程和子进程拥有独立的地址空间和PID参数、不同的父进程号、自己的文件描述符。

#### 1.1.9 什么是进程上下文、中断上下文

- 概述
  
  内核态和用户态都有自己的内存映射，即有自己的地址空间。

- 进程上下文
  
  因为有不同运行状态，才存在上下文。进程上下文，就是指一个进程在执行时，CPU中所有寄存器的值，进程的状态以及堆栈的内容，当内核需要切换到另一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该程序时，能恢复道切换时的状态，继续执行。

- 中断上下文
  
  - 中断上下文可以理解为硬件传递来的一些参数和内核需要保存的一些环境，主要是被中断的进程的环境。
  
  - 运行再中断上下文的代码有哪些大忌？
    
    - 睡眠或者放弃CPU，因为内核在进行中断前会关闭进程调度，一旦睡眠或者放弃CPU。这时内核无法调度别的进程来执行，系统就会死掉。
    
    - 尝试获得信号量，如果得不到信号量，代码就会和上述状态一样。
    
    - 执行耗时任务，如果中断处理时间过长，占用CPU太长时间会影响系统的功能。
    
    - 访问用户虚拟地址，因为这是再内核态运行，无法访问用户空间的虚拟地址。
      
      
